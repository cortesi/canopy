searchState.loadedDescShard("canopy_core", 0, "Core types and traits for the Canopy terminal UI library.\nBinder provides an ergonomic way to specify a set of key …\nThe API exposed to nodes by Canopy.\nDerive an implementation of the StatefulNode trait for a …\nAn <code>Expanse</code> is a rectangle that has a width and height but …\nInformation about a focusable node\nThe InputMap struct manages the global set of key and …\nA InputMode contains a set of bound keys and mouse actions.\nThe Layout struct provides operations that a node can …\nA trait that allows widgets to perform recursive …\nThe Poller is responsible for scheduling poll events for …\nA rectangle\nDerive an implementation of the StatefulNode trait for a …\nA ViewPort manages the size of a node and its projection …\nA stack of viewports that manages nested view …\nLoad the commands from a command node using the default …\nThe area of this expanse.\nThe width times the height of the rectangle\nAssert that the buffer matches the expected lines with …\nAssert that the buffer matches the expected lines with …\nReturn a rect with the same size, with the top left at the …\nBind a key, within a given mode, with a given context to a …\nBind a key in the global mode, with a given path filter to …\nBind a key within a given mode, with a given path filter …\nBind a mouse action in a specified mode with a given path …\nBind a mouse action in the global mode with a given path …\nA helper macro to create buffers for the termbuf match …\nReturns true if the buffer content matches the expected …\nThe canvas size for this viewport.\nCarve a rectangle with a fixed width out of the end of the …\nCarve a rectangle with a fixed width out of the start of …\nCarve a rectangle with a fixed height out of the end of …\nCarve a rectangle with a fixed height out of the start of …\nClamp a point, constraining it to fall within <code>rect</code>.\nClamp this rectangle, shifting it to lie within another …\nCollect all focusable nodes with their screen rectangles\nMark a method as a command. This macro should be used to …\nTrue if this Size can completely enclose the target size …\nDoes this rectangle contain the point?\nDoes this rectangle completely enclose the other? If other …\nDoes the buffer contain the supplied substring?\nDoes the buffer contain the supplied substring in the …\nDoes the buffer contain the supplied substring with the …\nCopy non-NULL characters from a rectangle of another …\nCopy non-NULL characters from a source TermBuf into a …\nCurrent focus generation counter.\nCurrent focus generation counter.\nConstructs a zero-valued size.\nAdd the default bindings for a widget.\nDerive an implementation of the <code>CommandNode</code> trait. This …\nDiff this terminal buffer against a previous state, …\nCreate an empty TermBuf filled with NULL characters\nCreate an empty TermBuf filled with NULL characters\nStop the render backend and exit the process.\nStop the render backend and exit the process.\nReturn the <code>Expanse</code> of this rectangle, which has the same …\nFill a node to occupy the given size, resetting its view …\nFill all empty (NULL) cells with the given character and …\nFill a node to occupy the given size while preserving its …\nFind the best focus target in the specified direction\nFind the currently focused node and its screen rectangle\nAdjust a child node so that it fits a viewport. This lays …\nSet the node size and the target view size at the same …\nMove focus in a specified direction within the subtree at …\nMove focus in a specified direction within the subtree at …\nMove focus downward of the currently focused node within …\nMove focus downward of the currently focused node within …\nFocus the first node that accepts focus in the pre-order …\nFocus the first node that accepts focus in the pre-order …\nMove focus to the left of the currently focused node …\nMove focus to the left of the currently focused node …\nFocus the next node in the pre-order traversal of root. If …\nFocus the next node in the pre-order traversal of root. If …\nReturn the focus path for the subtree under <code>root</code>.\nReturn the focus path for the subtree under <code>root</code>.\nFocus the previous node in the pre-order traversal of <code>root</code>…\nFocus the previous node in the pre-order traversal of <code>root</code>…\nMove focus to  right of the currently focused node within …\nMove focus to  right of the currently focused node within …\nMove focus upward of the currently focused node within the …\nMove focus upward of the currently focused node within the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeight\nCalculates the (pre, active, post) rectangles needed to …\nThe horizontal extent of this rect.\nHides the element and all its descendants from rendering. …\nExtract a horizontal section of this rect based on an …\nExtracts an inner rectangle, given a border width. If the …\nCalculate the intersection of this rectangle and another.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes the node have focus?\nDoes the node have terminal focus?\nIs the specified node on the focus path? A node is on the …\nIs the specified node on the focus path? A node is on the …\nDoes this rect have a zero size?\nBind a key to a script, panicing if there is any error …\nReturn the contents of a line as a <code>String</code>.\nReturn the contents of the buffer as lines of text. NULL …\nBind a mouse action to a script, panicing if there is any …\nDoes the node need to render in the next sweep? This …\nDoes the node need to render in the next sweep? This …\nCreate a new View with the given outer and inner …\nHas the focus path status of this node changed since the …\nScroll the view down by one page. Returns <code>true</code> if movement …\nScroll the view down by one page. Returns <code>true</code> if movement …\nScroll the view up by one page. Returns <code>true</code> if movement …\nScroll the view up by one page. Returns <code>true</code> if movement …\nPlace a child in a given sub-rectangle of a parent’s …\nLay the child out and place it in a given sub-rectangle of …\nPosition of this ViewPort’s view within the parent …\nOutput a formatted table of commands to a writer.\nCalculates the projection from the final viewport’s …\nGiven a point that falls within this rectangle, shift the …\nGiven a rectangle contained within this rectangle, shift …\nReturn a <code>Rect</code> with the same dimensions as the <code>Expanse</code>, but …\nRender this terminal buffer in full using the provided …\nGet a reference to the current render buffer, if any.\nResolve a key with a given path filter to a script.\nReturns the physical screen dimensions as a rectangle …\nSchedule a node to be polled. This function requires us to …\nAbsolute rectangle for the screen region the node is being …\nShift the point by an offset, avoiding under- or overflow.\nScroll the view by the given offsets. The view rectangle …\nScroll the view by the given offsets. The view rectangle …\nScroll the view down by one line. Returns <code>true</code> if movement …\nScroll the view down by one line. Returns <code>true</code> if movement …\nScroll the view left by one line. Returns <code>true</code> if movement …\nScroll the view left by one line. Returns <code>true</code> if movement …\nScroll the view right by one line. Returns <code>true</code> if …\nScroll the view right by one line. Returns <code>true</code> if …\nScroll the view right by one line.\nScroll the view to the specified position. The view is …\nScroll the view to the specified position. The view is …\nScroll the view up by one line. Returns <code>true</code> if movement …\nScroll the view up by one line. Returns <code>true</code> if movement …\nLike scroll, but constrained within a rectangle.\nSearches in a given direction sweeping to and fro. Stops …\nSweeps downwards from the bottom of the rectangle. Stops …\nSweeps leftwards the left of the rectangle. Stops once the …\nSweeps rightwards from the right of the rectangle. Stops …\nSweeps upwards from the top of the rectangle. Stops once …\nUpdate the canvas size for this viewport, clamping the …\nFocus a node. Returns <code>true</code> if focus changed.\nFocus a node. Returns <code>true</code> if focus changed.\nSet the viewport position. The caller must provide the …\nSet the view rectangle for a node.\nSet the visible view rectangle, clamped so that it always …\nA safe function for shifting the rectangle by an offset, …\nShift this rectangle, constrained to be within another …\nSplits the rectangle horizontally into n sections, as …\nSplits the rectangle into columns, with each column split …\nSplits the rectangle vertically into n sections, as close …\nStart the backend renderer.\nStart the backend renderer.\nStop the backend renderer, releasing control of the …\nStop the backend renderer, releasing control of the …\nSubtract a rectangle from this one, returning a set of …\nTaint a node to signal that it should be re-rendered.\nTaint a node for render.\nTaint the entire subtree under a node.\nMark a tree of nodes for render.\nTop-left corner\nGet the top viewport on the stack\nUtilities for working with a Canopy node tree.\nBind a key to a script fallibly.\nBind a mouse action to a script fallibly.\nUnhides the element and all its descendants, allowing them …\nCalculates the (pre, active, post) rectangles needed to …\nThe vertical extent of this rect.\nThis viewport’s view rectangle, relative to our own …\nExtract a slice of this rect based on a vertical extent.\nWidth\nSet the mode for subsequent bindings.\nSet the path filter for subsequent bindings.\nCreat a zero-sized <code>Rect</code> at the origin.\nA handle for controlling our rendering back-end. The …\nStop the render backend and exit the process.\nStart the backend renderer.\nStop the backend renderer, releasing control of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA dummy render backend that discards all output. This is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA simple in-memory canvas for verifying render placement …\nA handle to a vector that contains the result of the …\nA render backend for testing, which logs render outcomes.\nCreate returns a <code>TestBuf</code> protected by a mutex, and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrack which cells have been written to during a render.\nA parsed command invocation.\nThe CommandNode trait is implemented by all Nodes to …\nCommandDefinition encapsulates the definition of a command …\nThe return type of a command.\nThe return type of a command.\nNo return value.\nArguments to the command.\nThe name of the command.\nThe name of the command.\nReturn a list of commands for this node.\nDispatch a command relative to a node. This searches the …\nDispatch a command to this node.\nA doc string taken from the method comment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA full command name, of the form nodename.command\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the node.\nThe name of the node.\nIs the return wrapped in a <code>Result</code>? That is, is the method …\nThe return type of the command.\nWhat is the ultimate type of the return?\nShould the cursor blink?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLocation of the cursor, relative to (0, 0) in the node …\nShape of the cursor.\nTraverses a tree of nodes and returns a string showing the …\nTraverses a tree of nodes and returns a string showing the …\nContains the error value\nNo result was generated on node traversal\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis enum represents all the event types that drive the …\nTerminal has gained focus\nTerminal has lost focus\nA keystroke\nA mouse action\nCut and paste\nA poll event\nTerminal resize\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module contains the core primitives to represent …\nShift + Tab key.\nA character.\nF key.\nFast-forward media key.\nIso Level3 Shift key.\nIso Level5 Shift key.\nA keystroke along with modifiers.\nLeft Alt key.\nLeft Control key.\nLeft Hyper key.\nLeft Meta key.\nLeft Shift key.\nLeft Super key.\nLower-volume media key.\nMute media key.\nPause media key.\nPlay media key.\nPlay/Pause media key.\nRaise-volume media key.\nRecord media key.\nReverse media key.\nRewind media key.\nRight Alt key.\nRight Control key.\nRight Hyper key.\nRight Meta key.\nRight Shift key.\nRight Super key.\nStop media key.\nNext-track media key.\nPrevious-track media key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHandling of the shift key is the most intricate part of …\nAn abstract specification for a mouse action\nA mouse input event. This has the same fields as the <code>Mouse</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a button-driven action?\nThe event was processed, but nothing changed so rendering …\nThe result of an event handler.\nThe event was processed and the node should be rendered.\nThe event was not handled and will bubble up the tree.\nNodes are the basic building-blocks of a Canopy UI. They …\nAttempt to focus this node. If the node accepts focus, it …\nCall a closure on this node’s children. If any child …\nCalled for each node on the focus path, after each render …\nForce the node to render in the next sweep. Over-riding …\nReturns the argument unchanged.\nHandle a key input event. This event is only called for …\nHandle a mouse input event. The default implementation …\nCalls <code>U::from(self)</code>.\nRe-compute the size and view of the node to display in the …\nThe scheduled poll endpoint. This function is called for …\nRender this widget, only drawing itself with reference to …\nA match expression that can be applied to paths.\nCheck whether the path filter matches a given path. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPop an item off the end of the path, modifying it in …\nA renderer that only renders to a specific rectangle …\nThe trait implemented by renderers.\nExit the process, relinquishing screen control.\nFill a rectangle with a specified character.\nFlush output to the terminal.\nReturns the argument unchanged.\nGet a reference to the internal buffer\nCalls <code>U::from(self)</code>.\nDraw a solid frame\nApply a style to the following text output\nThe style manager used to apply styles.\nOutput text to screen. This method is used for all text …\nPrint text in the specified line. If the text is wider …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA unique ID for a node.\nA node name, which consists of lowercase ASCII …\nAn opaque structure that Canopy uses to track node state. …\nThe interface implemented by all nodes that track state.\nTakes a string and munges it into a valid node name. It …\nSet both the canvas size and the view to fill the target …\nSet the node size and the target view size at the same …\nThis node’s focus generation. We increment the global …\nSet to be equal to the focus_gen during a pre-render …\nSet to the <code>render_gen</code> during the pre-render sweep if focus …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHides the element and all its descendants from rendering. …\nA unique ID for this node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this element hidden?\nHas this node been initialized? That is, has its poll …\nThe name of this node, used for debugging and command …\nScroll the view down by the height of the view rectangle.\nScroll the view up by the height of the view rectangle.\nIf this is equal to the global render_gen, we render …\nScroll the view by the given offsets.\nScroll the view down by one line.\nScroll the view left by one line.\nScroll the view right by one line.\nScroll the view to the specified position.\nScroll the view up by one line.\nSet our canvas size.\nSet the size of the node’s canvas.\nSet the node’s position within the parent canvas.\nSet our view position and size.\nSet the portion of the node that is displayed.\nGet a reference to the node’s state object.\nGet a mutable reference to the node’s state object.\nHides the element\nThe view for this node. The inner rectangle always has the …\nGet the node’s <code>ViewPort</code>.\nWrap around a child by laying it out in our viewport, then …\nAn ANSI color. See 256 colors - cheat sheet for more info.\nA text attribute.\nA set of active text attributes.\nA possibly partial style specification, which is stored in …\nA resolved style specification.\nA hierarchical style manager.\nAdd a style at a specified path.\nInsert a style attribute at a specified path.\nInsert a background color at a specified path.\nInsert a foreground color at a specified path.\nCreate a new PartialStyle with only attributes.\nCreate a new PartialStyle with only a background color.\nConstruct an empty set of text attributes.\nCreate a new PartialStyle with only a foreground color.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nResolve a style path.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this attribute set empty?\nConstruct a set of text attributes with a single attribute …\nPush onto the layer stack with the current render level.\nA helper for progressive construction of attribute sets.\nContinue walking, but don’t mark the event as handled.\nHandle an event with a possible return value and stop …\nSkip this node and continue walking. The meaning of Skip …\nWalk is the return value from traversal closures.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDid the traversal return Continue?\nDid the traversal return Handle?\nCalls a closure on the root node under (x, y), then …\nFind the ID of the leaf node at a given point.\nReturn the node path for a specified node id, relative to …\nA postorder traversal of the nodes under e.\nWalk::Skip prunes all children of the current node from …\nThe handle value of the traversal, if any.\nCall a closure on the currently focused node and all its …\nCall a closure on the node with the specified <code>id</code>, and all …\nGrid test utility for creating configurable grid layouts\nThis module defines a standard tree of instrumented nodes …\nStop the render backend and exit the process.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStart the backend renderer.\nStop the backend renderer, releasing control of the …\nA leaf cell in the grid\nA container node with child nodes\nA test utility for creating grids with configurable …\nA node in the grid that can be either a leaf cell or a …\nGet the dimensions of the grid (number of cells in x and y)\nGet the expected grid size in pixels\nHelper to find the deepest leaf node at a given position\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new grid with specified recursion levels and …\nCreate a new leaf cell at the given coordinates\nCreate a new container or cell based on recursion level …\nCreate a new container or cell based on recursion level …\nCreate a new root node for the grid\nA simple harness that holds a <code>Canopy</code>, a <code>DummyBackend</code> …\nAccess the current render buffer. Panics if a render has …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a harness with a default root size of 100x100.\nCreate a harness using <code>size</code> for the root layout.\nThread-local state tracked by test nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet and reset the state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun a function on our standard dummy app built from [<code>ttree</code>]…")