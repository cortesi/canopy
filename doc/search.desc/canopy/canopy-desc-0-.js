searchState.loadedDescShard("canopy", 0, "A library for building terminal UIs.\nBinder provides an ergonomic way to specify a set of key …\nBinder provides an ergonomic way to specify a set of key …\nA parsed command invocation.\nThe CommandNode trait is implemented by all Nodes to …\nCommandDefinition encapsulates the definition of a command …\nThe event was processed, but nothing changed so rendering …\nThe API exposed to nodes by Canopy.\nDerive an implementation of the StatefulNode trait for a …\nContains the error value\nThe result of an event handler.\nAn <code>Expanse</code> is a rectangle that has a width and height but …\nInformation about a focusable node\nInformation about a focusable node\nThe event was processed and the node should be rendered.\nThe event was not handled and will bubble up the tree.\nThe InputMap struct manages the global set of key and …\nThe InputMap struct manages the global set of key and …\nA InputMode contains a set of bound keys and mouse actions.\nA InputMode contains a set of bound keys and mouse actions.\nThe Layout struct provides operations that a node can …\nA trait that allows widgets to perform recursive …\nA trait that allows widgets to perform recursive …\nNo result was generated on node traversal\nNodes are the basic building-blocks of a Canopy UI. They …\nA unique ID for a node.\nA node name, which consists of lowercase ASCII …\nAn opaque structure that Canopy uses to track node state. …\nContains the success value\nThe Poller is responsible for scheduling poll events for …\nThe Poller is responsible for scheduling poll events for …\nA rectangle\nA renderer that only renders to a specific rectangle …\nThe trait implemented by renderers.\nThe return type of a command.\nThe return type of a command.\nA Root node that lives at the base of a Canopy app. It …\nThe interface implemented by all nodes that track state.\nDerive an implementation of the StatefulNode trait for a …\nThe interface implemented by all nodes that track state.\nA ViewPort manages the size of a node and its projection …\nA stack of viewports that manages nested view …\nNo return value.\nAttempt to focus this node. If the node accepts focus, it …\nShow the inspector.\nLoad the commands from a command node using the default …\nThe area of this expanse.\nThe width times the height of the rectangle\nArguments to the command.\nReturn a rect with the same size, with the top left at the …\nBind a key, within a given mode, with a given context to a …\nBind a key in the global mode, with a given path filter to …\nBind a key within a given mode, with a given path filter …\nBind a mouse action in a specified mode with a given path …\nBind a mouse action in the global mode with a given path …\nGet a reference to the current render buffer, if any.\nA helper macro to create buffers for the termbuf match …\nThe canvas size for this viewport.\nCarve a rectangle with a fixed width out of the end of the …\nCarve a rectangle with a fixed width out of the start of …\nCarve a rectangle with a fixed height out of the end of …\nCarve a rectangle with a fixed height out of the start of …\nCall a closure on this node’s children. If any child …\nClamp a point, constraining it to fall within <code>rect</code>.\nClamp this rectangle, shifting it to lie within another …\nCollect all focusable nodes with their screen rectangles\nCollect all focusable nodes with their screen rectangles\nThe name of the command.\nThe name of the command.\nMark a method as a command. This macro should be used to …\nReturn a list of commands for this node.\nTrue if this Size can completely enclose the target size …\nDoes this rectangle contain the point?\nDoes this rectangle completely enclose the other? If other …\nTakes a string and munges it into a valid node name. It …\nCopy non-NULL characters from a rectangle of another …\nCopy non-NULL characters from a source TermBuf into a …\nCurrent focus generation counter.\nCalled for each node on the focus path, after each render …\nConstructs a zero-valued size.\nAdd the default bindings for a widget.\nDerive an implementation of the <code>CommandNode</code> trait. This …\nDiff this terminal buffer against a previous state, …\nDispatch a command relative to a node. This searches the …\nDispatch a command to this node.\nA doc string taken from the method comment.\nCreate an empty TermBuf filled with NULL characters\nCreate an empty TermBuf filled with NULL characters\nStop the render backend and exit the process.\nExit the process, relinquishing screen control.\nStop the render backend and exit the process.\nReturn the <code>Expanse</code> of this rectangle, which has the same …\nFill a node to occupy the given size, resetting its view …\nFill a rectangle with a specified character. Writes out of …\nSet both the canvas size and the view to fill the target …\nSet both the canvas size and the view to fill the target …\nFill all empty (NULL) cells with the given character and …\nFill a node to occupy the given size while preserving its …\nFind the best focus target in the specified direction\nFind the best focus target in the specified direction\nFind the currently focused node and its screen rectangle\nFind the currently focused node and its screen rectangle\nAdjust a child node so that it fits a viewport. This lays …\nSet the node size and the target view size at the same …\nSet the node size and the target view size at the same …\nFlush output to the terminal.\nIf we’re currently focused in the inspector, shift focus …\nMove focus in a specified direction within the subtree at …\nMove focus in a specified direction within the subtree at …\nMove focus downward of the currently focused node within …\nShift focus down.\nMove focus downward of the currently focused node within …\nFocus the first node that accepts focus in the pre-order …\nFocus the first node that accepts focus in the pre-order …\nThis node’s focus generation. We increment the global …\nMove focus to the left of the currently focused node …\nShift focus left.\nMove focus to the left of the currently focused node …\nFocus the next node in the pre-order traversal of root. If …\nFocus the next node in a pre-order traversal of the app.\nFocus the next node in the pre-order traversal of root. If …\nReturn the focus path for the subtree under <code>root</code>.\nReturn the focus path for the subtree under <code>root</code>.\nSet to be equal to the focus_gen during a pre-render …\nSet to the <code>render_gen</code> during the pre-render sweep if focus …\nFocus the previous node in the pre-order traversal of <code>root</code>…\nFocus the next node in a pre-order traversal of the app.\nFocus the previous node in the pre-order traversal of <code>root</code>…\nMove focus to  right of the currently focused node within …\nShift focus right.\nMove focus to  right of the currently focused node within …\nMove focus upward of the currently focused node within the …\nShift focus up.\nMove focus upward of the currently focused node within the …\nForce the node to render in the next sweep. Over-riding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA full command name, of the form nodename.command\nGet a reference to the internal buffer\nHeight\nCalculates the (pre, active, post) rectangles needed to …\nHandle a key input event. This event is only called for …\nHandle a mouse input event. The default implementation …\nThe horizontal extent of this rect.\nHides the element and all its descendants from rendering. …\nHides the element and all its descendants from rendering. …\nHides the element and all its descendants from rendering. …\nHide the inspector.\nExtract a horizontal section of this rect based on an …\nA unique ID for this node.\nA unique ID for this node.\nExtracts an inner rectangle, given a border width. If the …\nCalculate the intersection of this rectangle and another.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes the node have focus?\nDoes the node have terminal focus?\nIs this element hidden?\nIs this element hidden?\nHas this node been initialized? That is, has its poll …\nHas this node been initialized? That is, has its poll …\nIs the specified node on the focus path? A node is on the …\nIs the specified node on the focus path? A node is on the …\nDoes this rect have a zero size?\nBind a key to a script, panicing if there is any error …\nRe-compute the size and view of the node to display in the …\nBind a mouse action to a script, panicing if there is any …\nThe name of this node, used for debugging and command …\nThe name of this node, used for debugging and command …\nDoes the node need to render in the next sweep? This …\nDoes the node need to render in the next sweep? This …\nCreate a new View with the given outer and inner …\nThe name of the node.\nThe name of the node.\nHas the focus path status of this node changed since the …\nScroll the view down by one page. Returns <code>true</code> if movement …\nScroll the view down by the height of the view rectangle.\nScroll the view up by one page. Returns <code>true</code> if movement …\nScroll the view up by the height of the view rectangle.\nPlace a child in a given sub-rectangle of a parent’s …\nLay the child out and place it in a given sub-rectangle of …\nThe scheduled poll endpoint. This function is called for …\nPosition of this ViewPort’s view within the parent …\nOutput a formatted table of commands to a writer.\nCalculates the projection from the final viewport’s …\nExit from the program, restoring terminal state. If the …\nGiven a point that falls within this rectangle, shift the …\nGiven a rectangle contained within this rectangle, shift …\nReturn a <code>Rect</code> with the same dimensions as the <code>Expanse</code>, but …\nRender this widget, only drawing itself with reference to …\nRender this terminal buffer in full using the provided …\nIf this is equal to the global render_gen, we render …\nResolve a key with a given path filter to a script.\nIs the return wrapped in a <code>Result</code>? That is, is the method …\nThe return type of the command.\nReturns the physical screen dimensions as a rectangle …\nSchedule a node to be polled. This function requires us to …\nAbsolute rectangle for the screen region the node is being …\nShift the point by an offset, avoiding under- or overflow.\nScroll the view by the given offsets. The view rectangle …\nScroll the view by the given offsets.\nScroll the view down by one line. Returns <code>true</code> if movement …\nScroll the view down by one line.\nScroll the view left by one line. Returns <code>true</code> if movement …\nScroll the view left by one line.\nScroll the view right by one line. Returns <code>true</code> if …\nScroll the view right by one line.\nScroll the view right by one line.\nScroll the view to the specified position. The view is …\nScroll the view to the specified position.\nScroll the view up by one line. Returns <code>true</code> if movement …\nScroll the view up by one line.\nLike scroll, but constrained within a rectangle.\nSearches in a given direction sweeping to and fro. Stops …\nSweeps downwards from the bottom of the rectangle. Stops …\nSweeps leftwards the left of the rectangle. Stops once the …\nSweeps rightwards from the right of the rectangle. Stops …\nSweeps upwards from the top of the rectangle. Stops once …\nSet our canvas size.\nSet our canvas size.\nSet the size of the node’s canvas.\nUpdate the canvas size for this viewport, clamping the …\nFocus a node. Returns <code>true</code> if focus changed.\nFocus a node. Returns <code>true</code> if focus changed.\nSet the node’s position within the parent canvas.\nSet the viewport position. The caller must provide the …\nSet the view rectangle for a node.\nSet our view position and size.\nSet our view position and size.\nSet the portion of the node that is displayed.\nSet the visible view rectangle, clamped so that it always …\nA safe function for shifting the rectangle by an offset, …\nShift this rectangle, constrained to be within another …\nDraw a solid frame\nSplits the rectangle horizontally into n sections, as …\nSplits the rectangle into columns, with each column split …\nSplits the rectangle vertically into n sections, as close …\nStart the backend renderer.\nStart the backend renderer.\nGet a reference to the node’s state object.\nGet a reference to the node’s state object.\nGet a mutable reference to the node’s state object.\nGet a mutable reference to the node’s state object.\nStop the backend renderer, releasing control of the …\nStop the backend renderer, releasing control of the …\nApply a style to the following text output\nThe style manager used to apply styles.\nSubtract a rectangle from this one, returning a set of …\nTaint a node to signal that it should be re-rendered.\nTaint a node for render.\nTaint the entire subtree under a node.\nMark a tree of nodes for render.\nOutput text to screen. This method is used for all text …\nPrint text in the specified line. If the text is wider …\nTop-left corner\nShow the inspector.\nGet the top viewport on the stack\nUtilities for working with a Canopy node tree.\nBind a key to a script fallibly.\nBind a mouse action to a script fallibly.\nWhat is the ultimate type of the return?\nUnhides the element and all its descendants, allowing them …\nHides the element\nHides the element\nCalculates the (pre, active, post) rectangles needed to …\nThe vertical extent of this rect.\nThis viewport’s view rectangle, relative to our own …\nThe view for this node. The inner rectangle always has the …\nGet the node’s <code>ViewPort</code>.\nGet the node’s <code>ViewPort</code>.\nExtract a slice of this rect based on a vertical extent.\nWidth\nStart with the inspector open.\nSet the mode for subsequent bindings.\nSet the path filter for subsequent bindings.\nWrap around a child by laying it out in our viewport, then …\nWrap around a child by laying it out in our viewport, then …\nCreat a zero-sized <code>Rect</code> at the origin.\nA handle for controlling our rendering back-end. The …\nStop the render backend and exit the process.\nStart the backend renderer.\nStop the backend renderer, releasing control of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA simple in-memory canvas for verifying render placement …\nA handle to a vector that contains the result of the …\nA render backend for testing, which logs render outcomes.\nCreate returns a <code>TestBuf</code> protected by a mutex, and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrack which cells have been written to during a render.\nA parsed command invocation.\nThe CommandNode trait is implemented by all Nodes to …\nCommandDefinition encapsulates the definition of a command …\nThe return type of a command.\nThe return type of a command.\nNo return value.\nArguments to the command.\nThe name of the command.\nThe name of the command.\nReturn a list of commands for this node.\nDispatch a command relative to a node. This searches the …\nDispatch a command to this node.\nA doc string taken from the method comment.\nThe name of the node.\nThe name of the node.\nIs the return wrapped in a <code>Result</code>? That is, is the method …\nThe return type of the command.\nWhat is the ultimate type of the return?\nShould the cursor blink?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLocation of the cursor, relative to (0, 0) in the node …\nShape of the cursor.\nTraverses a tree of nodes and returns a string showing the …\nTraverses a tree of nodes and returns a string showing the …\nContains the error value\nNo result was generated on node traversal\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis enum represents all the event types that drive the …\nTerminal has gained focus\nTerminal has lost focus\nA keystroke\nA mouse action\nCut and paste\nA poll event\nTerminal resize\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module contains the core primitives to represent …\nShift + Tab key.\nA character.\nF key.\nFast-forward media key.\nIso Level3 Shift key.\nIso Level5 Shift key.\nA keystroke along with modifiers.\nLeft Alt key.\nLeft Control key.\nLeft Hyper key.\nLeft Meta key.\nLeft Shift key.\nLeft Super key.\nLower-volume media key.\nMute media key.\nPause media key.\nPlay media key.\nPlay/Pause media key.\nRaise-volume media key.\nRecord media key.\nReverse media key.\nRewind media key.\nRight Alt key.\nRight Control key.\nRight Hyper key.\nRight Meta key.\nRight Shift key.\nRight Super key.\nStop media key.\nNext-track media key.\nPrevious-track media key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHandling of the shift key is the most intricate part of …\nAn abstract specification for a mouse action\nA mouse input event. This has the same fields as the <code>Mouse</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a button-driven action?\nContains the error value\nAn <code>Expanse</code> is a rectangle that has a width and height but …\nA frame extracted from a rectangle\nA horizontal line, one character high - essentially a Rect …\nAn exctent is a directionless one-dimensional line segment.\nContains the success value\nA rectangle\nAre these two line segments adjacent but non-overlapping?\nThe bottom of the frame, not including corners\nThe bottom left corner\nThe bottom right corner\nCarve off a fixed-size portion from the end of this …\nCarve off a fixed-size portion from the start of this …\nDoes other lie completely within this extent.\nConstructs a zero-valued size.\nReturn a line segment that encloses this line segment and …\nThe far limit of the extent.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeight\nGet the inner rect of the frame (the space inside the …\nReturn the intersection between this line segment and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe left of the frame, not including corners\nThe length of this extent.\nConstruct a new frame. If the rect is too small to fit the …\nThe offset of this extent.\nGet the outer rect of the frame (the original rect passed …\nThe right of the frame, not including corners\nSplit this extent into (pre, active, post) extents, based …\nTop-left corner\nThe top of the frame, not including corners\nThe top left corner\nThe top right corner\nWidth\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe event was processed, but nothing changed so rendering …\nThe result of an event handler.\nThe event was processed and the node should be rendered.\nThe event was not handled and will bubble up the tree.\nNodes are the basic building-blocks of a Canopy UI. They …\nAttempt to focus this node. If the node accepts focus, it …\nCall a closure on this node’s children. If any child …\nCalled for each node on the focus path, after each render …\nForce the node to render in the next sweep. Over-riding …\nHandle a key input event. This event is only called for …\nHandle a mouse input event. The default implementation …\nRe-compute the size and view of the node to display in the …\nThe scheduled poll endpoint. This function is called for …\nRender this widget, only drawing itself with reference to …\nA match expression that can be applied to paths.\nCheck whether the path filter matches a given path. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPop an item off the end of the path, modifying it in …\nA renderer that only renders to a specific rectangle …\nThe trait implemented by renderers.\nExit the process, relinquishing screen control.\nFlush output to the terminal.\nApply a style to the following text output\nThe style manager used to apply styles.\nOutput text to screen. This method is used for all text …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA unique ID for a node.\nA node name, which consists of lowercase ASCII …\nAn opaque structure that Canopy uses to track node state. …\nThe interface implemented by all nodes that track state.\nSet both the canvas size and the view to fill the target …\nThis node’s focus generation. We increment the global …\nSet to be equal to the focus_gen during a pre-render …\nSet to the <code>render_gen</code> during the pre-render sweep if focus …\nHides the element and all its descendants from rendering. …\nA unique ID for this node.\nIs this element hidden?\nHas this node been initialized? That is, has its poll …\nThe name of this node, used for debugging and command …\nIf this is equal to the global render_gen, we render …\nSet our canvas size.\nSet our view position and size.\nGet a reference to the node’s state object.\nGet a mutable reference to the node’s state object.\nHides the element\nThe view for this node. The inner rectangle always has the …\nGet the node’s <code>ViewPort</code>.\nWrap around a child by laying it out in our viewport, then …\nAn ANSI color. See 256 colors - cheat sheet for more info.\nA text attribute.\nA set of active text attributes.\nA possibly partial style specification, which is stored in …\nA resolved style specification.\nA hierarchical style manager.\nAdd a style at a specified path.\nInsert a style attribute at a specified path.\nInsert a background color at a specified path.\nInsert a foreground color at a specified path.\nCreate a new PartialStyle with only attributes.\nCreate a new PartialStyle with only a background color.\nConstruct an empty set of text attributes.\nCreate a new PartialStyle with only a foreground color.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nResolve a style path.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this attribute set empty?\nConstruct a set of text attributes with a single attribute …\nPush onto the layer stack with the current render level.\nA helper for progressive construction of attribute sets.\nContinue walking, but don’t mark the event as handled.\nHandle an event with a possible return value and stop …\nSkip this node and continue walking. The meaning of Skip …\nWalk is the return value from traversal closures.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDid the traversal return Continue?\nDid the traversal return Handle?\nCalls a closure on the root node under (x, y), then …\nFind the ID of the leaf node at a given point.\nReturn the node path for a specified node id, relative to …\nA postorder traversal of the nodes under e.\nWalk::Skip prunes all children of the current node from …\nThe handle value of the traversal, if any.\nCall a closure on the currently focused node and all its …\nCall a closure on the node with the specified <code>id</code>, and all …\nUtilities for working with TermBufs in tests.\nGrid test utility for creating configurable grid layouts\nThis module defines a standard tree of instrumented nodes …\nA struct for configuring buffer matching behavior. By …\nAssert that the buffer matches the expected lines with …\nAssert that the buffer matches the expected lines with …\nDoes the buffer contain the supplied substring?\nDoes the buffer contain the supplied substring in the …\nDoes the buffer contain the supplied substring with the …\nDumps the contents of the buffer to the terminal for …\nDumps a single line from the buffer to the terminal for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the contents of a line as a <code>String</code>.\nReturn the contents of the buffer as lines of text.\nReturns true if the buffer content matches the expected …\nCreate a new BufTest with a reference to a TermBuf.\nSet a character that matches any character in the buffer. …\nSet the character used to match NULL cells in the buffer. …\nStop the render backend and exit the process.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStart the backend renderer.\nStop the backend renderer, releasing control of the …\nA leaf cell in the grid\nA container node with child nodes\nA test utility for creating grids with configurable …\nA node in the grid that can be either a leaf cell or a …\nGet the dimensions of the grid (number of cells in x and y)\nGet the expected grid size in pixels\nHelper to find the deepest leaf node at a given position\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new grid with specified recursion levels and …\nCreate a new leaf cell at the given coordinates\nCreate a new container or cell based on recursion level …\nCreate a new container or cell based on recursion level …\nCreate a new root node for the grid\nA simple harness that holds a <code>Canopy</code>, a [<code>DummyBackend</code>] …\nBuilder for creating a test harness with a fluent API.\nThe backend used for rendering. In tests, this is a no-op …\nAccess the current render buffer. Panics if a render has …\nBuild the harness with the configured settings.\nCreate a harness builder for constructing a test harness …\nThe Canopy instance that manages the node tree and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a harness with a default root size of 100x100.\nThe root node of the UI under test.\nExecute a script on the app under test. The script is …\nSet the size of the harness viewport.\nGet a BufTest instance that references the current buffer. …\nCreate a harness using <code>size</code> for the root layout.\nA dummy render backend that discards all output. This is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThread-local state tracked by test nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nA command that appears only on leaf nodes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet and reset the state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun a function on our standard dummy app built from [<code>ttree</code>]…")