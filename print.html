<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canopy Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Canopy Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cortesi/canopy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canopy-a-terminal-ui-library-for-rust"><a class="header" href="#canopy-a-terminal-ui-library-for-rust">Canopy: a terminal UI library for Rust</a></h1>
<p>In a forest each tree spreads its branches wide to maximise access to sunlight, but also carefully avoids touching the
foliage of its neighbours. This phenomenon is called "crown shyness" - the forest canopy becomes an organic tiling of
the sky.</p>
<p><strong>Canopy</strong> works just the same, but in your terminal. Interface elements are arranged in an ordered tree, with each node
managing only its children, who manage their own children in turn, until the leaf nodes tile the screen without overlap.
All interface operations are defined cleanly as traversals of this node tree.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/layout.svg">
</center>
<p>Here we have a visualization of a node tree, and the corresponding terminal output. In this image, <strong>R</strong> is the
<a href="doc/canopy/struct.Root.html">Root</a> - a special node provided by Canopy. It exposes a set of standard commands (for
example to change focus or quit the application) and also manages utilities like the Inspector the context sensitive
help system. <strong>C</strong> is an an internal node - it doesn't display anything itself, but manages the size and location of
<strong>A</strong> and <strong>B</strong> within the area it's responsible for. In this example, the <strong>A</strong> has focus, which means that nodes <strong>C</strong>
and <strong>R</strong> are on the focus path. We'll talk more about focus management and how focus affects event handling later.</p>
<p>Canopy strictly enforces the node hierarchy. No node is able to draw outside of its allocated area - the co-ordinate
system used to draw to screen is relative to the node's own area.</p>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/rendering.svg">
</center>
<p>Rendering is done with a pre-order traversal of the tree. Since Rust is fast and terminals are slow, the key to
performance is to send as few operations to the terminal as possible. Canopy
renders all visible widgets into an off-screen buffer and diffs against the
previous frame to minimize terminal updates. During the traversal, each node's
<a href="doc/canopy/trait.Widget.html#tymethod.render"><code>Widget::render</code></a> method is
invoked in pre-order so children draw on top of parents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-example"><a class="header" href="#end-to-end-example">End-to-end example</a></h1>
<p>This page shows a minimal widget with a command, a key binding that invokes it, and a style
override.</p>
<h2 id="widget--command"><a class="header" href="#widget--command">Widget + command</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::{Context, ReadContext, Widget, derive_commands, command, error::Result, render::Render, state::NodeName};
use canopy_widgets::Text;

key!(LabelSlot: Text);

pub struct Counter {
    value: i64,
}

#[derive_commands]
impl Counter {
    pub fn new() -&gt; Self {
        Self { value: 0 }
    }

    #[command]
    pub fn inc(&amp;mut self, ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
        self.value = self.value.saturating_add(1);
        self.sync_label(ctx)
    }

    fn sync_label(&amp;self, ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
        let label = format!("count: {}", self.value);
        ctx.with_child::&lt;LabelSlot, _&gt;(|text, _| {
            text.set_raw(label);
            Ok(())
        })
    }
}

impl Widget for Counter {
    fn on_mount(&amp;mut self, ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
        ctx.add_keyed::&lt;LabelSlot&gt;(Text::new("count: 0"))?;
        Ok(())
    }

    fn render(&amp;mut self, _r: &amp;mut Render, _ctx: &amp;dyn ReadContext) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    fn name(&amp;self) -&gt; NodeName {
        NodeName::convert("counter")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="install-and-bind"><a class="header" href="#install-and-bind">Install and bind</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::Canopy;
use canopy_widgets::Root;

let mut canopy = Canopy::new();
canopy.add_commands::&lt;Counter&gt;()?;

// Replace the root widget for a minimal app.
canopy.core.replace_subtree(canopy.core.root_id(), Counter::new())?;

// Bind a key to the typed command.
canopy.bind_key_command('j', "", Counter::cmd_inc().call())?;
<span class="boring">}</span></code></pre></pre>
<h2 id="style-override"><a class="header" href="#style-override">Style override</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::style::{Attr, StyleMap, solarized};

let mut style = StyleMap::new();
style
    .rules()
    .fg("counter", solarized::BASE3)
    .bg("counter", solarized::BASE02)
    .attr("counter", Attr::Bold)
    .apply();

canopy.style = style;
<span class="boring">}</span></code></pre></pre>
<p>The key pieces are:</p>
<ul>
<li><code>#[derive_commands]</code> + <code>#[command]</code> for command metadata</li>
<li><code>cmd_*().call()</code> for a typed invocation</li>
<li>path-based styles to keep appearance separate from behavior</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Each node in a Canopy application tree is a data container managed by the
<a href="doc/canopy/struct.Core.html"><code>Core</code></a>. Nodes are identified by <code>NodeId</code> handles
and store a <a href="doc/canopy/trait.Widget.html"><code>Widget</code></a> implementation that
provides behavior.</p>
<p>Widgets are also <a href="doc/canopy/commands/trait.CommandNode.html"><code>CommandNode</code></a>s,
so they can expose commands and handle dispatch. Finally, every node has a
name used for paths and bindings; see <a href="./state.html">Node names</a>.</p>
<h2 id="tree-structure"><a class="header" href="#tree-structure">Tree structure</a></h2>
<p>Nodes live in the core arena and are either attached to the root or detached. A node is attached
when it is reachable from <code>Core.root</code> by following <code>children</code>. Detached nodes are in the arena but
not in the active tree.</p>
<h2 id="creating-and-attaching-nodes"><a class="header" href="#creating-and-attaching-nodes">Creating and attaching nodes</a></h2>
<p>Use the create-and-attach APIs when possible. <code>Context::add_child</code> and
<code>Context::add_child_to</code> create a widget and attach it in one step, with
transactional behavior: on error, the tree and arena are unchanged.</p>
<p><code>Context::create_detached</code> allocates a node without attaching it; pair it with <code>attach</code> when you
need to reparent or build a subtree off-screen. <code>detach</code> removes a node from its parent but leaves
it in the arena. <code>remove_subtree</code> deletes a node and its descendants; see
<a href="./lifecycle.html">Lifecycle</a> for ordering and teardown.</p>
<h2 id="keyed-children"><a class="header" href="#keyed-children">Keyed children</a></h2>
<p>Keyed children provide stable names for direct child roles such as <code>"label"</code> or <code>"status"</code>. Keys
are unique per parent, and the association is removed when a child is detached. Use
<code>add_child_keyed</code>/<code>add_child_to_keyed</code> to create keyed children, <code>child_keyed</code> to look them up, and
<code>with_keyed</code>/<code>try_with_keyed</code> for typed access.</p>
<h2 id="typed-and-path-lookups"><a class="header" href="#typed-and-path-lookups">Typed and path lookups</a></h2>
<p>Type-based queries traverse in pre-order. Use <code>unique_child</code>/<code>unique_descendant</code> (and their
<code>with_*</code> variants) when you expect exactly one match; they surface ambiguity instead of silently
choosing the first match. Path helpers <code>find_one</code> and <code>try_find_one</code> enforce the same uniqueness
guarantee for path queries.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h2>
<ul>
<li>Prefer keyed children for stable internal roles.</li>
<li>Use <code>unique_*</code> lookups when the structure guarantees a single match; avoid <code>first_*</code> in complex
widgets.</li>
<li>Store <code>NodeId</code>s or keys for hot paths; avoid repeated deep traversal in per-frame loops.</li>
<li>Use <code>create_detached</code> + <code>attach</code> only when you need to reparent or stage a subtree.</li>
<li>Use <code>remove_subtree</code> for deletion so lifecycle hooks run and invariants are enforced.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-names"><a class="header" href="#node-names">Node names</a></h1>
<p>Every node in the tree has a <strong>node name</strong>, which is used for command dispatch
and path matching in input bindings. Names are stored as a <code>NodeName</code>, which is
validated to contain only lowercase ASCII letters, digits, and underscores.</p>
<h2 id="default-naming"><a class="header" href="#default-naming">Default naming</a></h2>
<p>Widgets can override <code>Widget::name</code> to control the node name, but if they
don't, the default implementation converts the Rust type name to snake case and
removes invalid characters. This means a widget named <code>FocusGym</code> becomes the
node name <code>focus_gym</code>.</p>
<h2 id="manual-conversion"><a class="header" href="#manual-conversion">Manual conversion</a></h2>
<p>If you need to construct a node name yourself, use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::state::NodeName;

let name = NodeName::convert("MyWidget");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Commands provide a uniform way to invoke widget behavior from Rust and from scripts. Each widget
exposes a static list of <code>CommandSpec</code> values, and the runtime routes invocations to the correct
node based on command metadata and focus context.</p>
<h2 id="defining-commands"><a class="header" href="#defining-commands">Defining commands</a></h2>
<p>Widgets implement the <code>CommandNode</code> trait. You almost never write it by hand; instead, use the
<code>#[derive_commands]</code> macro on an impl block and tag command methods with <code>#[command]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::{Context, ReadContext, Widget, derive_commands, command, error::Result, render::Render, state::NodeName};

struct Counter {
    value: i64,
}

#[derive_commands]
impl Counter {
    pub fn new() -&gt; Self {
        Self { value: 0 }
    }

    #[command]
    fn inc(&amp;mut self, _ctx: &amp;mut dyn Context) {
        self.value = self.value.saturating_add(1);
    }

    #[command]
    fn add(&amp;mut self, _ctx: &amp;mut dyn Context, delta: i64) {
        self.value = self.value.saturating_add(delta);
    }
}

impl Widget for Counter {
    fn render(&amp;mut self, _r: &amp;mut Render, _ctx: &amp;dyn ReadContext) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    fn name(&amp;self) -&gt; NodeName {
        NodeName::convert("counter")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The derive also generates <code>cmd_*()</code> helpers for building typed calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let call = Counter::cmd_add().call_with((5,));
ctx.dispatch_command(&amp;call.invocation())?;
<span class="boring">}</span></code></pre></pre>
<h2 id="command-registration"><a class="header" href="#command-registration">Command registration</a></h2>
<p>Commands must be registered on the <code>Canopy</code> instance to be available for dispatch or scripting.
Register widget command sets once during initialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canopy.add_commands::&lt;Counter&gt;()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="arguments-and-conversions"><a class="header" href="#arguments-and-conversions">Arguments and conversions</a></h2>
<p>Command parameters use <code>ArgValue</code> conversions. Built-in conversions include:</p>
<ul>
<li><code>bool</code>, <code>String</code>, <code>&amp;str</code></li>
<li>integers and floats</li>
<li><code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, maps (<code>BTreeMap</code>/<code>HashMap</code>) where <code>T: ToArgValue</code></li>
</ul>
<p>For custom types, derive <code>CommandArg</code> (serde-backed):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, canopy::CommandArg)]
struct MyArgs {
    name: String,
    count: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="injection"><a class="header" href="#injection">Injection</a></h2>
<p>Some parameter types are injected by the runtime rather than supplied by the caller:</p>
<ul>
<li><code>Event</code></li>
<li><code>MouseEvent</code></li>
<li><code>ListRowContext</code></li>
<li><code>Option&lt;T&gt;</code> for optional injection</li>
<li><code>Injected&lt;T&gt;</code> to explicitly request injection</li>
<li><code>Arg&lt;T&gt;</code> to force a caller-supplied argument even if <code>T</code> is injectable</li>
</ul>
<p>Injected values are sourced from the current command scope (event, mouse, list row).</p>
<h2 id="return-values"><a class="header" href="#return-values">Return values</a></h2>
<p>Commands can return:</p>
<ul>
<li><code>()</code> or <code>Result&lt;()&gt;</code></li>
<li>any type that implements <code>FromArgValue</code></li>
<li><code>Result&lt;T&gt;</code> where <code>T: FromArgValue</code></li>
</ul>
<p>Use <code>#[command(ignore_result)]</code> when the result should be available in Rust but not surfaced in
scripting.</p>
<h2 id="dispatch-and-invocation"><a class="header" href="#dispatch-and-invocation">Dispatch and invocation</a></h2>
<p><code>CommandCall</code> and <code>CommandInvocation</code> are the portable representations of a command call:</p>
<ul>
<li><code>CommandSpec::call()</code> builds a call with no args</li>
<li><code>CommandSpec::call_with(...)</code> builds with positional or named args</li>
<li><code>CommandCall::invocation()</code> produces the concrete <code>CommandInvocation</code></li>
</ul>
<p>Bindings (key/mouse) can target either scripts or typed command invocations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget"><a class="header" href="#widget">Widget</a></h1>
<p>Widgets provide the behavior attached to nodes in the Core arena. Every widget
implements the <code>Widget</code> trait, which includes:</p>
<ul>
<li><code>layout</code> to describe layout configuration for this widget</li>
<li><code>render</code> to draw the widget into a buffer</li>
<li><code>measure</code> to report intrinsic size (used by layout)</li>
<li><code>canvas</code> to report content size for scrolling/clipping (defaults to the view size)</li>
<li><code>on_event</code> to handle input events</li>
<li><code>poll</code> for scheduled updates</li>
<li><code>accept_focus</code> and <code>cursor</code> for focus handling</li>
<li><code>on_mount</code> for one-time initialization after first attachment</li>
<li><code>pre_remove</code> to validate or veto removal</li>
<li><code>on_unmount</code> for best-effort teardown before deletion</li>
</ul>
<p>Widgets are also <code>CommandNode</code>s, so they can expose commands used by the
scripting and binding system. By default, a widget's node name is derived from
its type name; see <a href="./state.html">Node names</a>.</p>
<p>The lifecycle hooks are described in more detail in <a href="./lifecycle.html">Lifecycle</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h1>
<p>Widgets move through a simple lifecycle driven by attachment and removal.</p>
<h2 id="mounting"><a class="header" href="#mounting">Mounting</a></h2>
<p><code>Widget::on_mount</code> runs exactly once, the first time a node becomes attached to the root. Nodes are
mounted in pre-order (parent before children). Detaching and re-attaching a mounted node does not
re-run <code>on_mount</code>.</p>
<h2 id="detaching"><a class="header" href="#detaching">Detaching</a></h2>
<p><code>detach</code> removes a node from its parent without deleting it. The node remains in the arena and
keeps its mounted state.</p>
<h2 id="removal"><a class="header" href="#removal">Removal</a></h2>
<p><code>remove_subtree</code> deletes a node and its descendants. It runs in three phases:</p>
<ul>
<li><code>pre_remove</code> top-down to validate or veto removal.</li>
<li><code>on_unmount</code> bottom-up while the nodes are still attached.</li>
<li>Detach and delete the subtree, then enforce focus and mouse capture invariants.</li>
</ul>
<p><code>pre_remove</code> should be side-effect free or safe to repeat. <code>on_unmount</code> is best-effort and must
not fail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p>Layout is probably the most complex part of Canopy, and understanding the
principles behind it will make writing powerful widgets much easier.</p>
<h2 id="view"><a class="header" href="#view">View</a></h2>
<p>Layout computes a <code>View</code> for every node. A view captures:</p>
<ul>
<li><strong>Outer rect</strong>: the node's allocated rectangle in screen coordinates.</li>
<li><strong>Content rect</strong>: the inner rectangle after subtracting padding (also in screen
coordinates). Children are laid out and clipped to this area.</li>
<li><strong>Scroll offset</strong>: the top-left of the visible window in content coordinates.</li>
<li><strong>Canvas size</strong>: the total scrollable extent in content coordinates.</li>
</ul>
<p>Children are positioned in the parent's content coordinate space. During render,
the engine translates child positions by the parent's scroll offset and clips
children to the parent's content rect. Widgets can query the current view to draw
scrollbars or react to available content space.</p>
<h2 id="fit"><a class="header" href="#fit">Fit</a></h2>
<h2 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polling"><a class="header" href="#polling">Polling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor"><a class="header" href="#cursor">Cursor</a></h1>
<p>For historical reasons, terminals don't distinguish between the location of the
visible cursor and the draw location for rendering. Drawing with the cursor
turned on will result in a visible cursor moving over the screen. Canopy manages
this by turning cursors off during rendering, and then enabling the cursor
during a separate cursor sweep afterwards. The cursor sweep gives all nodes on
the focus path the opportunity to define a cursor location and style using the
<code>cursor</code> method on the Node trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h1>
<img width=300 style="padding: 20px;" src="assets/keyevent.png">
<p>Key events are passed down from the current focus to the root, with the
<strong>Node::handle_key</strong> method called on each node. Keys are only handled once - we
stop passing the event along once the first node indicates that it's been
handled. Rendering occurs after each event; <strong>EventOutcome</strong> only controls
propagation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<img width=300 style="padding: 20px;" src="assets/mouseevent.png">
<p>Mouse events are independent of the focus - we locate the leaf node that is
under the mouse cursor, then pass event through the path from the leaf to the
root for handling. For each node on the path, the <strong>Node::handle_mouse</strong> method
is called, and we stop after the first node handles the event. Rendering occurs
after each event; <strong>EventOutcome</strong> only controls propagation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus"><a class="header" href="#focus">Focus</a></h1>
<img width=300 style="padding: 20px;" src="assets/focus.png">
<p>Eactly one node has <strong>focus</strong> at any one time. If a node has focus, its
ancestors up to the root of the tree are on the <strong>focus path</strong>. A corollary of
this is that the root node is always on the focus path. Nodes advertise whether
they can accept focus by implementing the <strong>can_focus</strong> method of the <strong>Node</strong>
trait - any node can accept focus, even if it's not a leaf.</p>
<p>Canopy provides various functions for controlling the focus in a subtree. These are
usually used from event handlers, letting a node control the focus location in
the subtree below it.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-next.png"/>
        <center style="font-weight: bold">focus::next</center>
    </div>
    <div style="display: inline-block; padding: 10px;">
        <img width=250 src="assets/focus-prev.png"/>
        <center style="font-weight: bold">focus::prev</center>
    </div>
</div>
<p>The <strong>focus::next</strong> and <strong>focus::prev</strong> functions set focus to the next and
previous nodes that accept focus in the pre-order traversal of the tree. In the
images above, the grey nodes accept focus, and the red arrow shows where focus
will move with respect to the pre-order traversal.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-up.png"/>
        <center style="font-weight: bold">focus::up</center>
    </div>
    <div style="display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-right.png"/>
        <center style="font-weight: bold">focus::right</center>
    </div>
</div>
<p>Canopy also has the spatial focus functions <strong>focus::{up,down,left,right}</strong>.
These functions take the screen area of the currently focused node, then search
for nodes that accept focus in the specified direction to choose the new focus.</p>
<p>When a node's focus status changes, it is automatically invalidated for the next render sweep.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-system"><a class="header" href="#binding-system">Binding system</a></h1>
<p>Bindings map input events (keys or mouse actions) to either scripts or typed command invocations.
Bindings are resolved against the focused node's path and can be scoped by mode.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<p>Script binding:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canopy.bind_key('q', "", "root::quit()")?;
<span class="boring">}</span></code></pre></pre>
<p>Typed command binding:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canopy.bind_key_command('q', "", Root::cmd_quit().call())?;
<span class="boring">}</span></code></pre></pre>
<p>The empty path filter (<code>""</code>) matches any focus path.</p>
<h2 id="modes"><a class="header" href="#modes">Modes</a></h2>
<p>Bindings live in named modes. Use the default mode (<code>""</code>) or set a mode explicitly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canopy.bind_mode_key('j', "nav", "", "editor::down()")?;
canopy.keymap.set_mode("nav")?;
<span class="boring">}</span></code></pre></pre>
<p>If the current mode does not match a binding, Canopy falls back to the default mode.</p>
<h2 id="path-filters"><a class="header" href="#path-filters">Path filters</a></h2>
<p>Bindings include a path filter string. The filter is matched against the focus path, and the most
specific match wins. Path filters are slash-separated components; <code>*</code> matches any component span.</p>
<p>Examples:</p>
<ul>
<li><code>""</code> matches all paths</li>
<li><code>"editor"</code> matches any path containing <code>editor</code></li>
<li><code>"/root/editor"</code> anchors to the root</li>
<li><code>"editor/"</code> anchors to the end</li>
<li><code>"editor/*/line"</code> matches a line widget anywhere under editor</li>
</ul>
<h2 id="mouse-bindings"><a class="header" href="#mouse-bindings">Mouse bindings</a></h2>
<p>Mouse bindings use the same path filters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::event::mouse;

canopy.bind_mouse(mouse::MouseEvent::left_click(), "list", "list::activate()")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="binder-helper"><a class="header" href="#binder-helper">Binder helper</a></h2>
<p>The <code>Binder</code> helper offers a fluent API for building sets of bindings and scoping them by path.
It is especially useful in examples and apps with many bindings.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="themes-and-styling"><a class="header" href="#themes-and-styling">Themes and styling</a></h1>
<p>Canopy uses a path-based styling system. Widgets render with style names (strings like
"frame/focused"), and a <code>StyleMap</code> resolves those names into concrete colors and attributes.</p>
<h2 id="style-paths"><a class="header" href="#style-paths">Style paths</a></h2>
<p>Style paths are slash-separated components. The empty path <code>""</code> or <code>"/"</code> refers to the root style.
Child paths extend the base style and override only the fields you set.</p>
<p>Example paths:</p>
<ul>
<li><code>"frame"</code></li>
<li><code>"frame/focused"</code></li>
<li><code>"list/selected"</code></li>
</ul>
<h2 id="defining-a-style-map"><a class="header" href="#defining-a-style-map">Defining a style map</a></h2>
<p>A <code>StyleMap</code> stores partial style rules. You can build it with the fluent <code>rules()</code> API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::style::{Attr, StyleMap, StyleRules, solarized};

let mut style = StyleMap::new();
style
    .rules()
    .fg("frame", solarized::BASE0)
    .fg("frame/focused", solarized::BASE3)
    .bg("list/selected", solarized::BLUE)
    .attr("list/selected", Attr::Bold)
    .apply();
<span class="boring">}</span></code></pre></pre>
<p>You can also add attributes directly with <code>StyleMap::add_attr</code> for small tweaks.</p>
<h2 id="applying-styles"><a class="header" href="#applying-styles">Applying styles</a></h2>
<p>To switch the active style map at runtime, call <code>Context::set_style</code>. The new style map is applied
before the next render.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.set_style(style_map);
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-with-styles"><a class="header" href="#rendering-with-styles">Rendering with styles</a></h2>
<p>Rendering APIs accept a style path string. The resolved style is computed by merging rules along
that path.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render(&amp;mut self, r: &amp;mut Render, ctx: &amp;dyn ReadContext) -&gt; Result&lt;()&gt; {
    let line = ctx.view().outer_rect_local().line(0);
    r.text("frame/focused", line, "Hello")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="paint-and-gradients"><a class="header" href="#paint-and-gradients">Paint and gradients</a></h2>
<p>Style foreground and background channels now accept <code>Paint</code>, which can be a solid color or a
gradient. Gradients are defined with an angle (in degrees) and color stops.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::style::{GradientSpec, Paint, StyleMap, solarized};

let mut style = StyleMap::new();
style
    .rules()
    .fg(
        "banner",
        Paint::gradient(GradientSpec::new(
            90.0,
            solarized::CYAN,
            solarized::BLUE,
        )),
    )
    .apply();
<span class="boring">}</span></code></pre></pre>
<p>Renderers resolve gradients per-cell within the supplied bounds, so the same style can be reused
for different sized widgets.</p>
<h2 id="style-effects"><a class="header" href="#style-effects">Style effects</a></h2>
<p>Style effects are dynamic, composable transforms that apply to a subtree. They are pushed via the
context and combined during render.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::style::effects;

ctx.push_effect(ctx.node_id(), effects::dim(0.5))?;
<span class="boring">}</span></code></pre></pre>
<p>Effects are useful for overlays, disabled states, or hover/focus treatments that should apply to
all descendants without redefining their rules.</p>
<h2 id="theme-modules"><a class="header" href="#theme-modules">Theme modules</a></h2>
<p>Canopy ships with a few theme palettes (<code>solarized</code>, <code>dracula</code>, <code>gruvbox</code>) under
<code>canopy::style</code>. Use them to build a <code>StyleMap</code> or as a starting point for your own theme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<p>This page collects practical patterns for building composable widgets with the current APIs.</p>
<h2 id="typed-ids"><a class="header" href="#typed-ids">Typed IDs</a></h2>
<p>Prefer <code>TypedId&lt;T&gt;</code> for widget IDs when you have a concrete type. It removes repetitive casts and
works with helpers like <code>Context::with_typed</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label_id = ctx.add_child(Text::new("Hello"))?;
ctx.with_typed(label_id, |text, _| {
    text.set_raw("Updated");
    Ok(())
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="keyed-children-1"><a class="header" href="#keyed-children-1">Keyed children</a></h2>
<p>Use typed child keys to manage stable internal children. Define a key with the <code>key!</code> macro, then
add or query the child by key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>key!(LabelSlot: Text);

fn on_mount(&amp;mut self, ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
    ctx.add_keyed::&lt;LabelSlot&gt;(Text::new("Label"))?;
    Ok(())
}

fn update_label(&amp;self, ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
    ctx.with_child::&lt;LabelSlot, _&gt;(|text, _| {
        text.set_raw("Updated");
        Ok(())
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="slot-pattern"><a class="header" href="#slot-pattern">Slot pattern</a></h2>
<p>For repeated access, cache a typed ID in your widget. This avoids searching the tree on every
update.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LabelSlot {
    id: Option&lt;TypedId&lt;Text&gt;&gt;,
}

impl LabelSlot {
    fn get_or_create(&amp;mut self, ctx: &amp;mut dyn Context) -&gt; Result&lt;TypedId&lt;Text&gt;&gt; {
        if let Some(id) = self.id {
            return Ok(id);
        }
        let id = ctx.add_child(Text::new("Label"))?;
        self.id = Some(id);
        Ok(id)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reconciling-dynamic-children"><a class="header" href="#reconciling-dynamic-children">Reconciling dynamic children</a></h2>
<p>When a container's children are driven by data, keep a stable map of keys to node IDs and
synchronize with <code>set_children</code>:</p>
<ul>
<li>create missing nodes</li>
<li>remove nodes that no longer exist (<code>remove_subtree</code>)</li>
<li>update ordering with <code>set_children</code></li>
</ul>
<p>This keeps the tree stable while letting you update only what changed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Canopy ships with a small widget library. This section highlights the editor and input widgets;
the rest follow the core <code>Widget</code> trait and the event/lifecycle guidelines in this book.</p>
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p>The <code>Editor</code> widget is a multi-line text editor that can also be configured for single-line input.
It supports wrapping, vi-style modal editing, mouse selection, search and replace, and optional
syntax highlighting.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p><code>EditorConfig</code> controls behavior:</p>
<ul>
<li><code>multiline</code>: Allow newlines. When false, Enter bubbles and newlines are normalized to spaces.</li>
<li><code>wrap</code>: <code>WrapMode::None</code> for horizontal scrolling, <code>WrapMode::Soft</code> for soft wrap.</li>
<li><code>auto_grow</code>, <code>min_height</code>, <code>max_height</code>: Size the editor to its content.</li>
<li><code>mode</code>: <code>EditMode::Text</code> or <code>EditMode::Vi</code>.</li>
<li><code>line_numbers</code>: <code>None</code>, <code>Absolute</code>, or <code>Relative</code>.</li>
<li><code>tab_stop</code>, <code>read_only</code>.</li>
</ul>
<h3 id="vi-mode"><a class="header" href="#vi-mode">Vi mode</a></h3>
<p>Normal/insert/visual with a focused subset:</p>
<ul>
<li>Motions: <code>h/j/k/l</code>, <code>w/b/e</code>, <code>0/$</code>, <code>^</code>, <code>gg/G</code>, <code>gj/gk</code>.</li>
<li>Edits: <code>x</code>, <code>dd</code>, <code>cc</code>, <code>D</code>, <code>C</code>, visual <code>d/y/c</code>, <code>&gt;</code>/<code>&lt;</code>.</li>
<li>Yank/put: <code>yy</code>, <code>p</code>, <code>P</code>.</li>
<li>Search: <code>/</code>, <code>?</code>, <code>n</code>, <code>N</code>, replace with <code>R</code>.</li>
<li>Undo/redo: <code>u</code>, <code>Ctrl+r</code>, repeat with <code>.</code>.</li>
</ul>
<h3 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax highlighting</a></h3>
<p>You can plug in a highlighter by implementing <code>Highlighter</code> or using <code>SyntectHighlighter</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::widgets::editor::{Editor, EditorConfig};
use canopy::widgets::editor::highlight::SyntectHighlighter;

let mut editor = Editor::with_config("", EditorConfig::new());
editor.set_highlighter(Some(Box::new(SyntectHighlighter::plain())));
<span class="boring">}</span></code></pre></pre>
<p>Highlight spans inherit the editor background, so themes only influence foreground colors and
attributes unless you supply a custom highlighter. The default syntect palette is
<code>Solarized (dark)</code> to match the editor's dark background.</p>
<p><code>SyntectHighlighter::with_theme_name</code> selects a named theme from syntect's default theme set, and
<code>SyntectHighlighter::with_theme</code> lets you pass a <code>Theme</code> directly for full palette control.</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>The <code>Input</code> widget is a single-line text field that shares the editor's buffer and column mapping
logic. It renders with horizontal scrolling to keep the cursor visible.</p>
<h2 id="terminal"><a class="header" href="#terminal">Terminal</a></h2>
<p><code>Terminal</code> embeds a PTY-backed terminal using <code>alacritty_terminal</code>.</p>
<p><code>TerminalConfig::kitty_keyboard</code> controls whether kitty keyboard protocol negotiation is enabled
(default on). When the child enables <code>DISAMBIGUATE_ESC_CODES</code>, the widget emits CSI-u sequences for
ambiguous modified keys; otherwise it falls back to legacy sequences.</p>
<p>For the crossterm backend, <code>RunloopOptions::enable_keyboard_enhancements</code> controls whether
<code>KeyboardEnhancementFlags::DISAMBIGUATE_ESCAPE_CODES</code> is pushed on startup.</p>
<h2 id="fontbanner"><a class="header" href="#fontbanner">FontBanner</a></h2>
<p><code>FontBanner</code> renders large terminal text from a TTF font into the available region. It scales to the
target height and clips overflow by default.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy_widgets::{Font, FontBanner, FontRenderer, LayoutOptions};

let font = Font::from_bytes(include_bytes!("MyFont-Regular.ttf"))?;
let renderer = FontRenderer::new(font);
let banner = FontBanner::new("Canopy", renderer).with_layout_options(LayoutOptions::default());
<span class="boring">}</span></code></pre></pre>
<p>Use the style system to apply solid or gradient paint to the banner via its style path.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
