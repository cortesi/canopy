<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canopy Manual</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="nodes.html"><strong aria-hidden="true">2.</strong> Nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">2.1.</strong> State</a></li><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">2.2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="layout.html"><strong aria-hidden="true">2.3.</strong> Layout</a></li><li class="chapter-item expanded "><a href="polling.html"><strong aria-hidden="true">2.4.</strong> Polling</a></li><li class="chapter-item expanded "><a href="cursor.html"><strong aria-hidden="true">2.5.</strong> Cursor</a></li></ol></li><li class="chapter-item expanded "><a href="focus.html"><strong aria-hidden="true">3.</strong> Focus</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">4.</strong> Event Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keyboard.html"><strong aria-hidden="true">4.1.</strong> Key events</a></li><li class="chapter-item expanded "><a href="mouse.html"><strong aria-hidden="true">4.2.</strong> Mouse events</a></li><li class="chapter-item expanded "><a href="lifecycle.html"><strong aria-hidden="true">4.3.</strong> Lifecycle events</a></li><li class="chapter-item expanded "><a href="bindings.html"><strong aria-hidden="true">4.4.</strong> Binding system</a></li></ol></li><li class="chapter-item expanded "><a href="scripting.html"><strong aria-hidden="true">5.</strong> Scripting</a></li><li class="chapter-item expanded "><a href="styling.html"><strong aria-hidden="true">6.</strong> Themes and Styling</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">7.</strong> Widget Library</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Canopy Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cortesi/canopy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canopy-a-terminal-ui-library-for-rust"><a class="header" href="#canopy-a-terminal-ui-library-for-rust">Canopy: a terminal UI library for Rust</a></h1>
<p>In a forest each tree spreads its branches wide to maximise access to sunlight, but also carefully avoids touching the
foliage of its neighbours. This phenomenon is called &quot;crown shyness&quot; - the forest canopy becomes an organic tiling of
the sky.</p>
<p><strong>Canopy</strong> works just the same, but in your terminal. Interface elements are arranged in an ordered tree, with each node
managing only its children, who manage their own children in turn, until the leaf nodes tile the screen without overlap.
All interface operations are defined cleanly as traversals of this node tree.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/layout.svg">
</center>
<p>Here we have a visualization of a node tree, and the corresponding terminal output. In this image, <strong>R</strong> is the
<a href="doc/canopy/struct.Root.html">Root</a> - a special node provided by Canopy. It exposes a set of standard commands (for
example to change focus or quit the application) and also manages utilities like the Inspector the context sensitive
help system. <strong>C</strong> is an an internal node - it doesn't display anything itself, but manages the size and location of
<strong>A</strong> and <strong>B</strong> within the area it's responsible for. In this example, the <strong>A</strong> has focus, which means that nodes <strong>C</strong>
and <strong>R</strong> are on the focus path. We'll talk more about focus management and how focus affects event handling later.</p>
<p>Canopy strictly enforces the node hierarchy. No node is able to draw outside of its allocated area - the co-ordinate
system used to draw to screen is relative to the node's own area.</p>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/rendering.svg">
</center>
<p>Rendering is done with a pre-order traversal of the tree. Since Rust is fast and terminals are slow, the key to
performance is to send as few operations to the terminal as possible. Canopy uses a mark-and-sweep mechanism to redraw
only what's needed. Nodes that need rendering are tainted using the
<a href="doc/canopy/trait.Core.html#tymethod.taint">Core.taint</a> or
<a href="doc/canopy/trait.Core.html#tymethod.taint_tree">Core.taint_tree</a> functions. Nodes are automatically tainted if they
handle an event or if their focus status changes. During the render sweep, we call the
<a href="doc/canopy/trait.Node.html#method.render">Node.render</a> method on each tainted node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Each node in a Canopy application tree implements three important traits:
<a href="doc/canopy/trait.StatefulNode.html">StatefulNode</a>, <a href="doc/canopy/commands/trait.CommandNode.html">CommandNode</a> and
<a href="doc/canopy/trait.Node.html">Node</a>. In the sections ahead we'll take a closer look at each of these traits and their
functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>Canopy tracks housekeeping data for each node - this includes whether the node has focus, the size and location of the
node, whether the node has been tainted, and so on. This data is tracked in an opaque structure called <code>NodeState</code>, and
each node is responsible for keeping its own state and returning it back to Canopy on request. The mechanism for doing
this is the <a href="doc/canopy/trait.StatefulNode.html">StatefulNode</a> trait. There are three functions that need to be implemented to support this trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The name of this node, used for debugging and command dispatch.
fn name(&amp;self) -&gt; NodeName;

/// Get a reference to the node's state object.
fn state(&amp;self) -&gt; &amp;NodeState;

/// Get a mutable reference to the node's state object.
fn state_mut(&amp;mut self) -&gt; &amp;mut NodeState;
<span class="boring">}</span></code></pre></pre>
<p>These are simple enough to implement by hand, but it's such common boilerplate that Canopy provides a macro to do this
for you. All you need to do is make sure that the struct for your node has an attribute called <code>state</code> of type
<code>NodeState</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(StatefulNode)]
struct MyNode {
    state: NodeState,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The derive macro takes the name of the struct as the node name - in this case it would be <code>MyNode</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polling"><a class="header" href="#polling">Polling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor"><a class="header" href="#cursor">Cursor</a></h1>
<p>For historical reasons, terminals don't distinguish between the location of the
visible cursor and the draw location for rendering. Drawing with the cursor
turned on will result in a visible cursor moving over the screen. Canopy manages
this by turning cursors off during rendering, and then enabling the cursor
during a separate cursor sweep afterwards. The cursor sweep gives all nodes on
the focus path the opportunity to define a cursor location and style using the
<code>cursor</code> method on the Node trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus"><a class="header" href="#focus">Focus</a></h1>
<img width=300 style="padding: 20px;" src="assets/focus.png">
<p>Eactly one node has <strong>focus</strong> at any one time. If a node has focus, its
ancestors up to the root of the tree are on the <strong>focus path</strong>. A corollary of
this is that the root node is always on the focus path. Nodes advertise whether
they can accept focus by implementing the <strong>can_focus</strong> method of the <strong>Node</strong>
trait - any node can accept focus, even if it's not a leaf.</p>
<p>Canopy provides various functions for controlling the focus in a subtree. These are
usually used from event handlers, letting a node control the focus location in
the subtree below it.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-next.png"/>
        <center style="font-weight: bold">focus::next</center>
    </div>
    <div style="display: inline-block; padding: 10px;">
        <img width=250 src="assets/focus-prev.png"/>
        <center style="font-weight: bold">focus::prev</center>
    </div>
</div>
<p>The <strong>focus::next</strong> and <strong>focus::prev</strong> functions set focus to the next and
previous nodes that accept focus in the pre-order traversal of the tree. In the
images above, the grey nodes accept focus, and the red arrow shows where focus
will move with respect to the pre-order traversal.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-up.png"/>
        <center style="font-weight: bold">focus::up</center>
    </div>
    <div style="display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-right.png"/>
        <center style="font-weight: bold">focus::right</center>
    </div>
</div>
<p>Canopy also has the spatial focus functions <strong>focus::{up,down,left,right}</strong>.
These functions take the screen area of the currently focused node, then search
for nodes that accept focus in the specified direction to choose the new focus.</p>
<p>When a node's focus status changes, it is automatically tainted for rendering in the next sweep.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h1>
<img width=300 style="padding: 20px;" src="assets/keyevent.png">
<p>Key events are passed down from the current focus to the root, with the
<strong>Node::handle_key</strong> method called on each node. Keys are only handled once - we
stop passing the event along once the first node indicates that it's been
handled. Handling a key event automatically taints the node, unless the
<strong>EventResult::no_render</strong> flag in the response object is true.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<img width=300 style="padding: 20px;" src="assets/mouseevent.png">
<p>Mouse events are independent of the focus - we locate the leaf node that is
under the mouse cursor, then pass event through the path from the leaf to the
root for handling. For each node on the path, the <strong>Node::handle_mouse</strong> method
is called, and we stop after the first node handles the event. Handling a mouse
event taints the node, unless the <strong>EventResult::no_render</strong> flag on the
response object is true.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-system"><a class="header" href="#binding-system">Binding system</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="themes-and-styling"><a class="header" href="#themes-and-styling">Themes and Styling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
