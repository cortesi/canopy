<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canopy Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Canopy Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cortesi/canopy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canopy-a-terminal-ui-library-for-rust"><a class="header" href="#canopy-a-terminal-ui-library-for-rust">Canopy: a terminal UI library for Rust</a></h1>
<p>In a forest each tree spreads its branches wide to maximise access to sunlight, but also carefully avoids touching the
foliage of its neighbours. This phenomenon is called "crown shyness" - the forest canopy becomes an organic tiling of
the sky.</p>
<p><strong>Canopy</strong> works just the same, but in your terminal. Interface elements are arranged in an ordered tree, with each node
managing only its children, who manage their own children in turn, until the leaf nodes tile the screen without overlap.
All interface operations are defined cleanly as traversals of this node tree.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/layout.svg">
</center>
<p>Here we have a visualization of a node tree, and the corresponding terminal output. In this image, <strong>R</strong> is the
<a href="doc/canopy/struct.Root.html">Root</a> - a special node provided by Canopy. It exposes a set of standard commands (for
example to change focus or quit the application) and also manages utilities like the Inspector the context sensitive
help system. <strong>C</strong> is an an internal node - it doesn't display anything itself, but manages the size and location of
<strong>A</strong> and <strong>B</strong> within the area it's responsible for. In this example, the <strong>A</strong> has focus, which means that nodes <strong>C</strong>
and <strong>R</strong> are on the focus path. We'll talk more about focus management and how focus affects event handling later.</p>
<p>Canopy strictly enforces the node hierarchy. No node is able to draw outside of its allocated area - the co-ordinate
system used to draw to screen is relative to the node's own area.</p>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<center>
    <img width=500px style="padding: 20px;" src="assets/rendering.svg">
</center>
<p>Rendering is done with a pre-order traversal of the tree. Since Rust is fast and terminals are slow, the key to
performance is to send as few operations to the terminal as possible. Canopy
renders all visible widgets into an off-screen buffer and diffs against the
previous frame to minimize terminal updates. During the traversal, each node's
<a href="doc/canopy/trait.Widget.html#tymethod.render"><code>Widget::render</code></a> method is
invoked in pre-order so children draw on top of parents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Each node in a Canopy application tree is a data container managed by the
<a href="doc/canopy/struct.Core.html"><code>Core</code></a>. Nodes are identified by <code>NodeId</code> handles
and store a <a href="doc/canopy/trait.Widget.html"><code>Widget</code></a> implementation that
provides behavior.</p>
<p>Widgets are also <a href="doc/canopy/commands/trait.CommandNode.html"><code>CommandNode</code></a>s,
so they can expose commands and handle dispatch. Finally, every node has a
name used for paths and bindings; see <a href="./state.html">Node names</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-names"><a class="header" href="#node-names">Node names</a></h1>
<p>Every node in the tree has a <strong>node name</strong>, which is used for command dispatch
and path matching in input bindings. Names are stored as a <code>NodeName</code>, which is
validated to contain only lowercase ASCII letters, digits, and underscores.</p>
<h2 id="default-naming"><a class="header" href="#default-naming">Default naming</a></h2>
<p>Widgets can override <code>Widget::name</code> to control the node name, but if they
don't, the default implementation converts the Rust type name to snake case and
removes invalid characters. This means a widget named <code>FocusGym</code> becomes the
node name <code>focus_gym</code>.</p>
<h2 id="manual-conversion"><a class="header" href="#manual-conversion">Manual conversion</a></h2>
<p>If you need to construct a node name yourself, use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::state::NodeName;

let name = NodeName::convert("MyWidget");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-commandnode"><a class="header" href="#trait-commandnode">trait CommandNode</a></h1>
<p>Commands drive much of Canopy's flexibility and are the core mechanism for
interacting with widgets. Widgets implement the
<a href="doc/canopy/commands/trait.CommandNode.html">CommandNode</a> trait, which has two
methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn commands() -&gt; Vec&lt;CommandSpec&gt;
    where Self: Sized;

fn dispatch(
    &amp;mut self,
    c: &amp;mut dyn Context,
    cmd: &amp;CommandInvocation
) -&gt; Result&lt;ReturnValue&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>commands</code> function returns a list of command specifications supported by
this widget. Each <code>CommandSpec</code> includes a name, description, and signature.
The <code>dispatch</code> function takes a <code>CommandInvocation</code> and runs the command.</p>
<p>Implementing these functions by hand is tedious, so Canopy provides derive
helpers. Use <code>#[derive_commands]</code> on the widget's impl block and annotate each
command with <code>#[command]</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyWidget {
    value: u64,
}

#[derive_commands]
impl MyWidget {
    /// Increment our value.
    #[command]
    fn inc(&amp;mut self, _ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
        self.value = self.value.saturating_add(1);
        Ok(())
    }

    /// Decrement our value.
    #[command]
    fn dec(&amp;mut self, _ctx: &amp;mut dyn Context) -&gt; Result&lt;()&gt; {
        self.value = self.value.saturating_sub(1);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="arguments"><a class="header" href="#arguments">Arguments</a></h1>
<p>Command functions can take an arbitrary number of arguments. The following
types are supported:</p>
<ul>
<li><code>&amp;mut dyn Context</code>. This is handled specially: if the first argument is of
type <code>&amp;mut dyn Context</code>, it is automatically supplied during dispatch and
cannot be specified in a script.</li>
<li><code>isize</code></li>
</ul>
<p>The list of supported types can be extended as needed.</p>
<h1 id="return-values"><a class="header" href="#return-values">Return values</a></h1>
<p>The following return value variants are supported:</p>
<ul>
<li>No return value.</li>
<li><code>String</code></li>
</ul>
<p>We also support <code>Result</code> variants of the above:</p>
<ul>
<li><code>Result&lt;()&gt;</code></li>
<li><code>Result&lt;T&gt;</code> where <code>T</code> is any supported type.</li>
</ul>
<p>Sometimes we want to expose a command that returns a value in Rust but has no
equivalent in the scripting layer. In those cases use
<code>#[command(ignore_result)]</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Delete the currently selected item.
#[command(ignore_result)]
pub fn delete_selected(&amp;mut self, ctx: &amp;mut dyn Context) -&gt; Option&lt;N&gt; {
    self.delete_item(ctx, self.offset)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget"><a class="header" href="#widget">Widget</a></h1>
<p>Widgets provide the behavior attached to nodes in the Core arena. Every widget
implements the <code>Widget</code> trait, which includes:</p>
<ul>
<li><code>layout</code> to describe layout configuration for this widget</li>
<li><code>render</code> to draw the widget into a buffer</li>
<li><code>measure</code> to report intrinsic size (used by layout)</li>
<li><code>canvas</code> to report content size for scrolling/clipping (defaults to the view size)</li>
<li><code>on_event</code> to handle input events</li>
<li><code>poll</code> for scheduled updates</li>
<li><code>accept_focus</code> and <code>cursor</code> for focus handling</li>
</ul>
<p>Widgets are also <code>CommandNode</code>s, so they can expose commands used by the
scripting and binding system. By default, a widget's node name is derived from
its type name; see <a href="./state.html">Node names</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p>Layout is probably the most complex part of Canopy, and understanding the
principles behind it will make writing powerful widgets much easier.</p>
<h2 id="view"><a class="header" href="#view">View</a></h2>
<p>Layout computes a <code>View</code> for every node. A view captures:</p>
<ul>
<li><strong>Outer rect</strong>: the node's allocated rectangle in screen coordinates.</li>
<li><strong>Content rect</strong>: the inner rectangle after subtracting padding (also in screen
coordinates). Children are laid out and clipped to this area.</li>
<li><strong>Scroll offset</strong>: the top-left of the visible window in content coordinates.</li>
<li><strong>Canvas size</strong>: the total scrollable extent in content coordinates.</li>
</ul>
<p>Children are positioned in the parent's content coordinate space. During render,
the engine translates child positions by the parent's scroll offset and clips
children to the parent's content rect. Widgets can query the current view to draw
scrollbars or react to available content space.</p>
<h2 id="fit"><a class="header" href="#fit">Fit</a></h2>
<h2 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polling"><a class="header" href="#polling">Polling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor"><a class="header" href="#cursor">Cursor</a></h1>
<p>For historical reasons, terminals don't distinguish between the location of the
visible cursor and the draw location for rendering. Drawing with the cursor
turned on will result in a visible cursor moving over the screen. Canopy manages
this by turning cursors off during rendering, and then enabling the cursor
during a separate cursor sweep afterwards. The cursor sweep gives all nodes on
the focus path the opportunity to define a cursor location and style using the
<code>cursor</code> method on the Node trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h1>
<img width=300 style="padding: 20px;" src="assets/keyevent.png">
<p>Key events are passed down from the current focus to the root, with the
<strong>Node::handle_key</strong> method called on each node. Keys are only handled once - we
stop passing the event along once the first node indicates that it's been
handled. Rendering occurs after each event; <strong>EventOutcome</strong> only controls
propagation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<img width=300 style="padding: 20px;" src="assets/mouseevent.png">
<p>Mouse events are independent of the focus - we locate the leaf node that is
under the mouse cursor, then pass event through the path from the leaf to the
root for handling. For each node on the path, the <strong>Node::handle_mouse</strong> method
is called, and we stop after the first node handles the event. Rendering occurs
after each event; <strong>EventOutcome</strong> only controls propagation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus"><a class="header" href="#focus">Focus</a></h1>
<img width=300 style="padding: 20px;" src="assets/focus.png">
<p>Eactly one node has <strong>focus</strong> at any one time. If a node has focus, its
ancestors up to the root of the tree are on the <strong>focus path</strong>. A corollary of
this is that the root node is always on the focus path. Nodes advertise whether
they can accept focus by implementing the <strong>can_focus</strong> method of the <strong>Node</strong>
trait - any node can accept focus, even if it's not a leaf.</p>
<p>Canopy provides various functions for controlling the focus in a subtree. These are
usually used from event handlers, letting a node control the focus location in
the subtree below it.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-next.png"/>
        <center style="font-weight: bold">focus::next</center>
    </div>
    <div style="display: inline-block; padding: 10px;">
        <img width=250 src="assets/focus-prev.png"/>
        <center style="font-weight: bold">focus::prev</center>
    </div>
</div>
<p>The <strong>focus::next</strong> and <strong>focus::prev</strong> functions set focus to the next and
previous nodes that accept focus in the pre-order traversal of the tree. In the
images above, the grey nodes accept focus, and the red arrow shows where focus
will move with respect to the pre-order traversal.</p>
<div>
    <div style="float: left; display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-up.png"/>
        <center style="font-weight: bold">focus::up</center>
    </div>
    <div style="display: inline-block; padding: 10px;" >
        <img width=250 src="assets/focus-right.png"/>
        <center style="font-weight: bold">focus::right</center>
    </div>
</div>
<p>Canopy also has the spatial focus functions <strong>focus::{up,down,left,right}</strong>.
These functions take the screen area of the currently focused node, then search
for nodes that accept focus in the specified direction to choose the new focus.</p>
<p>When a node's focus status changes, it is automatically invalidated for the next render sweep.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-system"><a class="header" href="#binding-system">Binding system</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="themes-and-styling"><a class="header" href="#themes-and-styling">Themes and Styling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Canopy ships with a small widget library. This section highlights the editor and input widgets;
the rest follow the core <code>Widget</code> trait and the event/lifecycle guidelines in this book.</p>
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p>The <code>Editor</code> widget is a multi-line text editor that can also be configured for single-line input.
It supports wrapping, vi-style modal editing, mouse selection, search and replace, and optional
syntax highlighting.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p><code>EditorConfig</code> controls behavior:</p>
<ul>
<li><code>multiline</code>: Allow newlines. When false, Enter bubbles and newlines are normalized to spaces.</li>
<li><code>wrap</code>: <code>WrapMode::None</code> for horizontal scrolling, <code>WrapMode::Soft</code> for soft wrap.</li>
<li><code>auto_grow</code>, <code>min_height</code>, <code>max_height</code>: Size the editor to its content.</li>
<li><code>mode</code>: <code>EditMode::Text</code> or <code>EditMode::Vi</code>.</li>
<li><code>line_numbers</code>: <code>None</code>, <code>Absolute</code>, or <code>Relative</code>.</li>
<li><code>tab_stop</code>, <code>read_only</code>.</li>
</ul>
<h3 id="vi-mode"><a class="header" href="#vi-mode">Vi mode</a></h3>
<p>Normal/insert/visual with a focused subset:</p>
<ul>
<li>Motions: <code>h/j/k/l</code>, <code>w/b/e</code>, <code>0/$</code>, <code>^</code>, <code>gg/G</code>, <code>gj/gk</code>.</li>
<li>Edits: <code>x</code>, <code>dd</code>, <code>cc</code>, <code>D</code>, <code>C</code>, visual <code>d/y/c</code>, <code>&gt;</code>/<code>&lt;</code>.</li>
<li>Yank/put: <code>yy</code>, <code>p</code>, <code>P</code>.</li>
<li>Search: <code>/</code>, <code>?</code>, <code>n</code>, <code>N</code>, replace with <code>R</code>.</li>
<li>Undo/redo: <code>u</code>, <code>Ctrl+r</code>, repeat with <code>.</code>.</li>
</ul>
<h3 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax highlighting</a></h3>
<p>You can plug in a highlighter by implementing <code>Highlighter</code> or using <code>SyntectHighlighter</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canopy::widgets::editor::{Editor, EditorConfig};
use canopy::widgets::editor::highlight::SyntectHighlighter;

let mut editor = Editor::with_config("", EditorConfig::new());
editor.set_highlighter(Some(Box::new(SyntectHighlighter::plain())));
<span class="boring">}</span></code></pre></pre>
<p>Highlight spans inherit the editor background, so themes only influence foreground colors and
attributes unless you supply a custom highlighter. The default syntect palette is
<code>Solarized (dark)</code> to match the editor's dark background.</p>
<p><code>SyntectHighlighter::with_theme_name</code> selects a named theme from syntect's default theme set, and
<code>SyntectHighlighter::with_theme</code> lets you pass a <code>Theme</code> directly for full palette control.</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>The <code>Input</code> widget is a single-line text field that shares the editor's buffer and column mapping
logic. It renders with horizontal scrolling to keep the cursor visible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
